# Black hat

Представим на время, что вы black hat, и у вас в распоряжении оказались данные ~30 млн.
заказов некоторого сервиса доставки еды за некоторый период 2021 и 2022 года.
Поверхностный анализ показал, что данные содержат 18 758 328 уникальных телефонов с полным именем клиента,
а средняя длина полного имени - 20 символов (латинских или кириллических).
Допустим, вы хотите развернуть веб-сервис, который позволит по номеру телефона найти полное имя клиента.
Но вы не хотите оставлять следы на диске или в базе данных - придется все держать в памяти.
Но еще вы не хотите зря тратить крипту на слишком большой сервер.

Поэтому давайте оценим, сколько памяти займут эти данные:
- если мы хотим реализовать поиск за постоянное время, т.е. O(1)?
- если мы хотим занять как можно меньше памяти?

Самое главное - объяснить, как вы пришли к той или иной числовой оценке.
Можно выбрать любой язык программирования/платформу.

# Решение
В качестве языка будет рассматриваться Java, а именно 32-разрядная JVM (это будет использоваться в подсчетах)

## Оптимизация по памяти
В основу эффективного хранения данных положена следующая структура данных:

Для хранения номеров телефонов мы будем использовать префиксное дерево (Trie), поскольку данная структура данных
позволяет эффективно хранить строки за счет устранения дублирования одинаковых префиксов, а также обеспечивает
выполнение основных операций за время O(K), где K - длина передаваемой строки.

Для хранения имен будет использоваться сжатое префиксное дерево (radix tree), основным отличием которого от упомянутого выше
обычного префиксного дерева является возможность "сжимать" образующиеся ветки (несколько последовательных узлов с
одним родителем и одним ребенком), что позволяет повысить эффективность хранения за счет дополнительного сжатия данных.

### Заметка:  
Для дерева номеров телефонов также можно использовать сжатое префиксное дерево, однако оно с большой вероятностью
выродится в обычное префиксное дерево ввиду небольшого алфавита (10 цифр) и небольшой длины строки (предполагается,
что все номера имеют длину 11 символов) на фоне большого количества уникальных данных.

Идея построения состоит в следующем:
1. Построим сжатое префиксное дерево для имен (в его узлах не будет храниться ссылок на какие-либо данные,
    но будет храниться ссылка на родительский узел, что в дальнейшем позволит восстанавливать из узла исходную строку,
    поднимаясь вверх до корня дерева).
2. Построим префиксное дерево для номеров (в узлах не будет ссылки на родителя, но будут ссылки на узлы из дерева имен,
   соответствующие данному телефонному номеру).

Поиск будет происходить следующим образом:
1. Выполним поиск в дереве номеров -> в результате получим ссылку на узел из дерева имен.
2. Из полученного узла дерева имен поднимемся по родительским ссылкам до корня дерева, восстановив тем самым
    исходное имя.

### Оценка
Для начала оценим количество узлов в каждом из деревьев в худшем случае - когда каждому номеру соответствует уникальное
имя.

Для сжатого префиксного дерева будет справедлива следующая оценка сверху для случая, когда верхние уровни дерева
максимально ветвятся, а в листьях находятся только остатки имен:

$$ T = \frac{1 - N^(l + 1)}{1 - N} + 2K$$

С $T - K$, содержащими 1 символ
И $K$ узлами, содержащими $K - l - 1$ символов

где 
- T - суммарное количество узлов
- N - мощность алфавита или максимальное кол-во детей в каждом узле (в расчетах равняется 34 (русский алфавит и пробел))
- K - количество слов в структуре данных
- L - длина каждого слова (для определенности полагается одинаковой)
- l - количество полностью заполненных уровней дерева начиная с корня (такое, что $N^l < K < N^(l+1)$)

