# Задание 1
Размещено в папке `src/main/java`.

# Задание 2

Представим на время, что вы black hat, и у вас в распоряжении оказались данные ~30 млн.
заказов некоторого сервиса доставки еды за некоторый период 2021 и 2022 года.
Поверхностный анализ показал, что данные содержат 18 758 328 уникальных телефонов с полным именем клиента,
а средняя длина полного имени - 20 символов (латинских или кириллических).
Допустим, вы хотите развернуть веб-сервис, который позволит по номеру телефона найти полное имя клиента.
Но вы не хотите оставлять следы на диске или в базе данных - придется все держать в памяти.
Но еще вы не хотите зря тратить крипту на слишком большой сервер.

Поэтому давайте оценим, сколько памяти займут эти данные:
- если мы хотим реализовать поиск за постоянное время, т.е. $O(1)$?
- если мы хотим занять как можно меньше памяти?

Самое главное - объяснить, как вы пришли к той или иной числовой оценке.
Можно выбрать любой язык программирования/платформу.

## Решение

Ниже будет представлено одно решение для обоих случаев, предоставляющее оптимальный компромисс как с точки зрения памяти, так и с точки зрения времени доступа.

В качестве языка будет рассматриваться Java, а именно 64-разрядная JVM (каждый объект имеет заголовок 16 байт, что будет в дальнейшем использоваться в расчетах).

Для хранения номеров телефонов и имен мы будем использовать сжатое префиксное дерево (Radix tree), поскольку такая структура данных
позволяет эффективно хранить строки за счет устранения дублирования одинаковых префиксов, а также обеспечивает
выполнение основных операций за время $O(K)$, где $K$ - длина передаваемой строки.

Идея построения состоит в следующем:
1. Построим сжатое префиксное дерево для имен (в его узлах не будет храниться ссылок на какие-либо данные,
    но будет храниться ссылка на родительский узел, что в дальнейшем позволит восстанавливать из узла исходную строку,
    поднимаясь вверх до корня дерева);
2. Построим сжатое префиксное дерево для номеров (в узлах не будет ссылки на родителя, но в листьях будут ссылки на узлы из дерева имен, соответствующих данному телефонному номеру).

Поиск будет происходить следующим образом:
1. Выполним поиск в дереве номеров -> в результате получим ссылку на узел из дерева имен;
2. Из полученного узла дерева имен поднимемся по родительским ссылкам до корня дерева, восстановив тем самым
    исходное имя.

### Оценка
Для начала оценим количество узлов в каждом из деревьев в худшем случае - когда каждому номеру соответствует уникальное
имя.

Для сжатого префиксного дерева будет справедлива следующая оценка сверху для случая, когда верхние уровни дерева
максимально ветвятся и узлы в них содержат по одному символу, а в листьях находятся оставшиеся суффиксы имен:

$$ T = \frac{1 - N^{l + 1}}{1 - N} + 2K$$

С $T - K$ узлами, содержащими 1 символ и $K$ узлами, содержащими $K - l - 1$ символов,

где 
- $T$ - суммарное количество узлов;
- $N$ - мощность алфавита или максимальное кол-во детей в каждом узле;
- $K$ - количество слов в структуре данных;
- $L$ - длина каждого слова (для определенности полагается одинаковой);
- $l$ - количество полностью заполненных уровней дерева начиная с корня (такое, что $N^l < K < N^{l+1}$).


Произведем расчет количества узлов в худшем случае согласно формулам при следующих параметрах:
- $N = 34$ (русский алфавит и пробел), $K = 18758328$, $L = 20$ и $l = 4$ для дерева имен;
- $N = 10$ (десятичные цифры), $K = 18758328$, $L = 11$ и $l = 7$ для дерева номеров.

Для первого случая получим:
- 20135159 узлов с 1 символом;
- 18758328 узлов с 15 символами.

Для второго случая:
- 29869439 узлов с 1 символом;
- 18758328 узлов с 3 символами.

Теперь приблизительно рассчитаем стоимость узла в каждом из деревьев.

Для дерева имен структура будет следующей:

    class NameNode {
        String letters;     // size == 1 -> 54 byte; size == 15 -> 82 byte
        Node parent;        // 4 byte
        Node[34] children;  // 156 byte
        // + 16 byte header
    }
    // 230 or 258 byte total
    
Для дерева номеров:

    class PhoneNode {
        String letters;     // size == 1 -> 54 byte; size == 3 -> 58 byte
        Node[10] children;  // 64 byte
        NameNode nameRef;   // 4 byte
        // + 16 byte header
    }
    // 138 or 142 byte total

Таким образом, умножаем количество нод на затрачиваемую ими память, суммируем и получаем итоговый результат:

$$ 20135159 * 230 + 18758328 * 258 + 29869439 * 138 + 18758328 * 142 = 16256400352 B = 16.25 GB $$

Временная сложность получения имени по номеру составляет $O(N + M)$, где $N$ - длина номера, а $M$ - длина имени.
Но поскольку длина номера фиксирована, а длина имени находится в довольно ограниченных пределах (допустим, не более 50 символов) и не может неограниченно расти, то данные параметры можно считать константными, что по итогу даст сложность $O(1)$.

### Замечания:
Расчеты потребления памяти были произведены на основе [этой статьи](https://habr.com/ru/articles/134102/).  
При подсчете памяти для строк не учитывается String pool, который на практике может существенно снизить потребление памяти.

